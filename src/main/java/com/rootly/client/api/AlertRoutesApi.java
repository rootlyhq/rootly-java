/*
 * Rootly API v1
 * # How to generate an API Key? - **Organization dropdown** > **Organization Settings** > **API Keys**  # JSON:API Specification Rootly is using **JSON:API** (https://jsonapi.org) specification: - JSON:API is a specification for how a client should request that resources be fetched or modified, and how a server should respond to those requests. - JSON:API is designed to minimize both the number of requests and the amount of data transmitted between clients and servers. This efficiency is achieved without compromising readability, flexibility, or discoverability. - JSON:API requires use of the JSON:API media type (**application/vnd.api+json**) for exchanging data.  # Authentication and Requests We use standard HTTP Authentication over HTTPS to authorize your requests. ```   curl --request GET \\ --header 'Content-Type: application/vnd.api+json' \\ --header 'Authorization: Bearer YOUR-TOKEN' \\ --url https://api.rootly.com/v1/incidents ```  <br/>  # Rate limiting - There is a default limit of **5** **GET**, **HEAD**, and **OPTIONS** calls **per API key** every **60 seconds** (0 hours). The limit is calculated over a **0-hour sliding window** looking back from the current time. While the limit can be configured to support higher thresholds, you must first contact your **Rootly Customer Success Manager** to make any adjustments. - There is a default limit of **3** **POST**, **PUT**, **PATCH** or **DELETE** calls **per API key** every **60 seconds** (0 hours). The limit is calculated over a **0-hour sliding window** looking back from the current time. While the limit can be configured to support higher thresholds, you must first contact your **Rootly Customer Success Manager** to make any adjustments. - When rate limits are exceeded, the API will return a **429 Too Many Requests** HTTP status code with the response: `{\"error\": \"Rate limit exceeded. Try again later.\"}` - **X-RateLimit headers** are included in every API response, providing real-time rate limit information:   - **X-RateLimit-Limit** - The maximum number of requests permitted and the time window (e.g., \"1000, 1000;window=3600\" for 1000 requests per hour)   - **X-RateLimit-Remaining** - The number of requests remaining in the current rate limit window   - **X-RateLimit-Used** - The number of requests already made in the current window   - **X-RateLimit-Reset** - The time at which the current rate limit window resets, in UTC epoch seconds  # Pagination - Pagination is supported for all endpoints that return a collection of items. - Pagination is controlled by the **page** query parameter  ## Example ```   curl --request GET \\ --header 'Content-Type: application/vnd.api+json' \\ --header 'Authorization: Bearer YOUR-TOKEN' \\ --url https://api.rootly.com/v1/incidents?page[number]=1&page[size]=10 ```  
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.rootly.client.api;

import com.rootly.client.ApiCallback;
import com.rootly.client.ApiClient;
import com.rootly.client.ApiException;
import com.rootly.client.ApiResponse;
import com.rootly.client.Configuration;
import com.rootly.client.Pair;
import com.rootly.client.ProgressRequestBody;
import com.rootly.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.rootly.client.model.AlertRouteList;
import com.rootly.client.model.AlertRouteResponse;
import com.rootly.client.model.DeleteAlertRoute200Response;
import com.rootly.client.model.ErrorsList;
import com.rootly.client.model.NewAlertRoute;
import com.rootly.client.model.UpdateAlertRoute;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class AlertRoutesApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public AlertRoutesApi() {
        this(Configuration.getDefaultApiClient());
    }

    public AlertRoutesApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for createAlertRoute
     * @param newAlertRoute  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> unknown attribute filtered out gracefully </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> create: raises error when multiple fallback rules are present </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> unauthorized </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createAlertRouteCall(@javax.annotation.Nonnull NewAlertRoute newAlertRoute, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = newAlertRoute;

        // create path and map variables
        String localVarPath = "/v1/alert_routes";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/vnd.api+json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/vnd.api+json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "bearer_auth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createAlertRouteValidateBeforeCall(@javax.annotation.Nonnull NewAlertRoute newAlertRoute, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'newAlertRoute' is set
        if (newAlertRoute == null) {
            throw new ApiException("Missing the required parameter 'newAlertRoute' when calling createAlertRoute(Async)");
        }

        return createAlertRouteCall(newAlertRoute, _callback);

    }

    /**
     * Creates an alert route
     * Creates a new alert route from provided data. **Note: This endpoint requires access to Advanced Alert Routing. If you&#39;re unsure whether you have access to this feature, please contact Rootly customer support.**  ## Asynchronous Rule Creation  For organizations with large numbers of routing rules, Rootly supports asynchronous rule processing to improve performance. When enabled, rule creation happens in the background.  **Important**: When async processing is enabled, the rules list in the API response will not be up-to-date immediately after creation. You should refetch the alert route after a few minutes to get the updated rules.  If you experience slow operations when managing alert routes with many rules, contact Rootly customer support to enable asynchronous rule processing for your organization.
     * @param newAlertRoute  (required)
     * @return AlertRouteResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> unknown attribute filtered out gracefully </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> create: raises error when multiple fallback rules are present </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> unauthorized </td><td>  -  </td></tr>
     </table>
     */
    public AlertRouteResponse createAlertRoute(@javax.annotation.Nonnull NewAlertRoute newAlertRoute) throws ApiException {
        ApiResponse<AlertRouteResponse> localVarResp = createAlertRouteWithHttpInfo(newAlertRoute);
        return localVarResp.getData();
    }

    /**
     * Creates an alert route
     * Creates a new alert route from provided data. **Note: This endpoint requires access to Advanced Alert Routing. If you&#39;re unsure whether you have access to this feature, please contact Rootly customer support.**  ## Asynchronous Rule Creation  For organizations with large numbers of routing rules, Rootly supports asynchronous rule processing to improve performance. When enabled, rule creation happens in the background.  **Important**: When async processing is enabled, the rules list in the API response will not be up-to-date immediately after creation. You should refetch the alert route after a few minutes to get the updated rules.  If you experience slow operations when managing alert routes with many rules, contact Rootly customer support to enable asynchronous rule processing for your organization.
     * @param newAlertRoute  (required)
     * @return ApiResponse&lt;AlertRouteResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> unknown attribute filtered out gracefully </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> create: raises error when multiple fallback rules are present </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> unauthorized </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<AlertRouteResponse> createAlertRouteWithHttpInfo(@javax.annotation.Nonnull NewAlertRoute newAlertRoute) throws ApiException {
        okhttp3.Call localVarCall = createAlertRouteValidateBeforeCall(newAlertRoute, null);
        Type localVarReturnType = new TypeToken<AlertRouteResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Creates an alert route (asynchronously)
     * Creates a new alert route from provided data. **Note: This endpoint requires access to Advanced Alert Routing. If you&#39;re unsure whether you have access to this feature, please contact Rootly customer support.**  ## Asynchronous Rule Creation  For organizations with large numbers of routing rules, Rootly supports asynchronous rule processing to improve performance. When enabled, rule creation happens in the background.  **Important**: When async processing is enabled, the rules list in the API response will not be up-to-date immediately after creation. You should refetch the alert route after a few minutes to get the updated rules.  If you experience slow operations when managing alert routes with many rules, contact Rootly customer support to enable asynchronous rule processing for your organization.
     * @param newAlertRoute  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> unknown attribute filtered out gracefully </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> create: raises error when multiple fallback rules are present </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> unauthorized </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createAlertRouteAsync(@javax.annotation.Nonnull NewAlertRoute newAlertRoute, final ApiCallback<AlertRouteResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = createAlertRouteValidateBeforeCall(newAlertRoute, _callback);
        Type localVarReturnType = new TypeToken<AlertRouteResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteAlertRoute
     * @param id  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> alert route deleted </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> cross-team access denied </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> destroy failed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> unauthorized </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteAlertRouteCall(@javax.annotation.Nonnull String id, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/alert_routes/{id}"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/vnd.api+json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "bearer_auth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteAlertRouteValidateBeforeCall(@javax.annotation.Nonnull String id, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling deleteAlertRoute(Async)");
        }

        return deleteAlertRouteCall(id, _callback);

    }

    /**
     * Delete an alert route
     * Delete a specific alert route by id. **Note: This endpoint requires access to Advanced Alert Routing. If you&#39;re unsure whether you have access to this feature, please contact Rootly customer support.**
     * @param id  (required)
     * @return DeleteAlertRoute200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> alert route deleted </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> cross-team access denied </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> destroy failed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> unauthorized </td><td>  -  </td></tr>
     </table>
     */
    public DeleteAlertRoute200Response deleteAlertRoute(@javax.annotation.Nonnull String id) throws ApiException {
        ApiResponse<DeleteAlertRoute200Response> localVarResp = deleteAlertRouteWithHttpInfo(id);
        return localVarResp.getData();
    }

    /**
     * Delete an alert route
     * Delete a specific alert route by id. **Note: This endpoint requires access to Advanced Alert Routing. If you&#39;re unsure whether you have access to this feature, please contact Rootly customer support.**
     * @param id  (required)
     * @return ApiResponse&lt;DeleteAlertRoute200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> alert route deleted </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> cross-team access denied </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> destroy failed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> unauthorized </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<DeleteAlertRoute200Response> deleteAlertRouteWithHttpInfo(@javax.annotation.Nonnull String id) throws ApiException {
        okhttp3.Call localVarCall = deleteAlertRouteValidateBeforeCall(id, null);
        Type localVarReturnType = new TypeToken<DeleteAlertRoute200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Delete an alert route (asynchronously)
     * Delete a specific alert route by id. **Note: This endpoint requires access to Advanced Alert Routing. If you&#39;re unsure whether you have access to this feature, please contact Rootly customer support.**
     * @param id  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> alert route deleted </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> cross-team access denied </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> destroy failed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> unauthorized </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteAlertRouteAsync(@javax.annotation.Nonnull String id, final ApiCallback<DeleteAlertRoute200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteAlertRouteValidateBeforeCall(id, _callback);
        Type localVarReturnType = new TypeToken<DeleteAlertRoute200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getAlertRoute
     * @param id  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> alert route found </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> cross-team access denied </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> unauthorized </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getAlertRouteCall(@javax.annotation.Nonnull String id, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/alert_routes/{id}"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/vnd.api+json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "bearer_auth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getAlertRouteValidateBeforeCall(@javax.annotation.Nonnull String id, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling getAlertRoute(Async)");
        }

        return getAlertRouteCall(id, _callback);

    }

    /**
     * Get an alert route
     * Get a specific alert route by id. **Note: This endpoint requires access to Advanced Alert Routing. If you&#39;re unsure whether you have access to this feature, please contact Rootly customer support.**
     * @param id  (required)
     * @return AlertRouteResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> alert route found </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> cross-team access denied </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> unauthorized </td><td>  -  </td></tr>
     </table>
     */
    public AlertRouteResponse getAlertRoute(@javax.annotation.Nonnull String id) throws ApiException {
        ApiResponse<AlertRouteResponse> localVarResp = getAlertRouteWithHttpInfo(id);
        return localVarResp.getData();
    }

    /**
     * Get an alert route
     * Get a specific alert route by id. **Note: This endpoint requires access to Advanced Alert Routing. If you&#39;re unsure whether you have access to this feature, please contact Rootly customer support.**
     * @param id  (required)
     * @return ApiResponse&lt;AlertRouteResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> alert route found </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> cross-team access denied </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> unauthorized </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<AlertRouteResponse> getAlertRouteWithHttpInfo(@javax.annotation.Nonnull String id) throws ApiException {
        okhttp3.Call localVarCall = getAlertRouteValidateBeforeCall(id, null);
        Type localVarReturnType = new TypeToken<AlertRouteResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get an alert route (asynchronously)
     * Get a specific alert route by id. **Note: This endpoint requires access to Advanced Alert Routing. If you&#39;re unsure whether you have access to this feature, please contact Rootly customer support.**
     * @param id  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> alert route found </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> cross-team access denied </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> unauthorized </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getAlertRouteAsync(@javax.annotation.Nonnull String id, final ApiCallback<AlertRouteResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getAlertRouteValidateBeforeCall(id, _callback);
        Type localVarReturnType = new TypeToken<AlertRouteResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for listAlertRoutes
     * @param pageNumber  (optional)
     * @param pageSize  (optional)
     * @param filterSearch  (optional)
     * @param filterName  (optional)
     * @param sort  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> alert routes filtered by search </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> unauthorized </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listAlertRoutesCall(@javax.annotation.Nullable Integer pageNumber, @javax.annotation.Nullable Integer pageSize, @javax.annotation.Nullable String filterSearch, @javax.annotation.Nullable String filterName, @javax.annotation.Nullable String sort, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/alert_routes";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (pageNumber != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page[number]", pageNumber));
        }

        if (pageSize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page[size]", pageSize));
        }

        if (filterSearch != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter[search]", filterSearch));
        }

        if (filterName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter[name]", filterName));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        final String[] localVarAccepts = {
            "application/vnd.api+json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "bearer_auth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listAlertRoutesValidateBeforeCall(@javax.annotation.Nullable Integer pageNumber, @javax.annotation.Nullable Integer pageSize, @javax.annotation.Nullable String filterSearch, @javax.annotation.Nullable String filterName, @javax.annotation.Nullable String sort, final ApiCallback _callback) throws ApiException {
        return listAlertRoutesCall(pageNumber, pageSize, filterSearch, filterName, sort, _callback);

    }

    /**
     * List alert routes
     * List all alert routes for the current team with filtering and pagination. **Note: This endpoint requires access to Advanced Alert Routing. If you&#39;re unsure whether you have access to this feature, please contact Rootly customer support.**
     * @param pageNumber  (optional)
     * @param pageSize  (optional)
     * @param filterSearch  (optional)
     * @param filterName  (optional)
     * @param sort  (optional)
     * @return AlertRouteList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> alert routes filtered by search </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> unauthorized </td><td>  -  </td></tr>
     </table>
     */
    public AlertRouteList listAlertRoutes(@javax.annotation.Nullable Integer pageNumber, @javax.annotation.Nullable Integer pageSize, @javax.annotation.Nullable String filterSearch, @javax.annotation.Nullable String filterName, @javax.annotation.Nullable String sort) throws ApiException {
        ApiResponse<AlertRouteList> localVarResp = listAlertRoutesWithHttpInfo(pageNumber, pageSize, filterSearch, filterName, sort);
        return localVarResp.getData();
    }

    /**
     * List alert routes
     * List all alert routes for the current team with filtering and pagination. **Note: This endpoint requires access to Advanced Alert Routing. If you&#39;re unsure whether you have access to this feature, please contact Rootly customer support.**
     * @param pageNumber  (optional)
     * @param pageSize  (optional)
     * @param filterSearch  (optional)
     * @param filterName  (optional)
     * @param sort  (optional)
     * @return ApiResponse&lt;AlertRouteList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> alert routes filtered by search </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> unauthorized </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<AlertRouteList> listAlertRoutesWithHttpInfo(@javax.annotation.Nullable Integer pageNumber, @javax.annotation.Nullable Integer pageSize, @javax.annotation.Nullable String filterSearch, @javax.annotation.Nullable String filterName, @javax.annotation.Nullable String sort) throws ApiException {
        okhttp3.Call localVarCall = listAlertRoutesValidateBeforeCall(pageNumber, pageSize, filterSearch, filterName, sort, null);
        Type localVarReturnType = new TypeToken<AlertRouteList>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List alert routes (asynchronously)
     * List all alert routes for the current team with filtering and pagination. **Note: This endpoint requires access to Advanced Alert Routing. If you&#39;re unsure whether you have access to this feature, please contact Rootly customer support.**
     * @param pageNumber  (optional)
     * @param pageSize  (optional)
     * @param filterSearch  (optional)
     * @param filterName  (optional)
     * @param sort  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> alert routes filtered by search </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> unauthorized </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listAlertRoutesAsync(@javax.annotation.Nullable Integer pageNumber, @javax.annotation.Nullable Integer pageSize, @javax.annotation.Nullable String filterSearch, @javax.annotation.Nullable String filterName, @javax.annotation.Nullable String sort, final ApiCallback<AlertRouteList> _callback) throws ApiException {

        okhttp3.Call localVarCall = listAlertRoutesValidateBeforeCall(pageNumber, pageSize, filterSearch, filterName, sort, _callback);
        Type localVarReturnType = new TypeToken<AlertRouteList>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateAlertRoute
     * @param id  (required)
     * @param updateAlertRoute  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> update: handles mixed position types correctly </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> update: raises error when multiple fallback rules are present </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> cross-team access denied </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateAlertRouteCall(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull UpdateAlertRoute updateAlertRoute, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = updateAlertRoute;

        // create path and map variables
        String localVarPath = "/v1/alert_routes/{id}"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/vnd.api+json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/vnd.api+json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "bearer_auth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateAlertRouteValidateBeforeCall(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull UpdateAlertRoute updateAlertRoute, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling updateAlertRoute(Async)");
        }

        // verify the required parameter 'updateAlertRoute' is set
        if (updateAlertRoute == null) {
            throw new ApiException("Missing the required parameter 'updateAlertRoute' when calling updateAlertRoute(Async)");
        }

        return updateAlertRouteCall(id, updateAlertRoute, _callback);

    }

    /**
     * Update an alert route
     * Update a specific alert route by id. **Note: This endpoint requires access to Advanced Alert Routing. If you&#39;re unsure whether you have access to this feature, please contact Rootly customer support.**  ## Asynchronous Rule Creation  For organizations with large numbers of routing rules, Rootly supports asynchronous rule processing to improve performance. When enabled, rule updates happen in the background.  **Important**: When async processing is enabled, the rules list in the API response will not be up-to-date immediately after update. You should refetch the alert route after a few minutes to get the updated rules.  If you experience slow operations when managing alert routes with many rules, contact Rootly customer support to enable asynchronous rule processing for your organization.
     * @param id  (required)
     * @param updateAlertRoute  (required)
     * @return AlertRouteResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> update: handles mixed position types correctly </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> update: raises error when multiple fallback rules are present </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> cross-team access denied </td><td>  -  </td></tr>
     </table>
     */
    public AlertRouteResponse updateAlertRoute(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull UpdateAlertRoute updateAlertRoute) throws ApiException {
        ApiResponse<AlertRouteResponse> localVarResp = updateAlertRouteWithHttpInfo(id, updateAlertRoute);
        return localVarResp.getData();
    }

    /**
     * Update an alert route
     * Update a specific alert route by id. **Note: This endpoint requires access to Advanced Alert Routing. If you&#39;re unsure whether you have access to this feature, please contact Rootly customer support.**  ## Asynchronous Rule Creation  For organizations with large numbers of routing rules, Rootly supports asynchronous rule processing to improve performance. When enabled, rule updates happen in the background.  **Important**: When async processing is enabled, the rules list in the API response will not be up-to-date immediately after update. You should refetch the alert route after a few minutes to get the updated rules.  If you experience slow operations when managing alert routes with many rules, contact Rootly customer support to enable asynchronous rule processing for your organization.
     * @param id  (required)
     * @param updateAlertRoute  (required)
     * @return ApiResponse&lt;AlertRouteResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> update: handles mixed position types correctly </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> update: raises error when multiple fallback rules are present </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> cross-team access denied </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<AlertRouteResponse> updateAlertRouteWithHttpInfo(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull UpdateAlertRoute updateAlertRoute) throws ApiException {
        okhttp3.Call localVarCall = updateAlertRouteValidateBeforeCall(id, updateAlertRoute, null);
        Type localVarReturnType = new TypeToken<AlertRouteResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update an alert route (asynchronously)
     * Update a specific alert route by id. **Note: This endpoint requires access to Advanced Alert Routing. If you&#39;re unsure whether you have access to this feature, please contact Rootly customer support.**  ## Asynchronous Rule Creation  For organizations with large numbers of routing rules, Rootly supports asynchronous rule processing to improve performance. When enabled, rule updates happen in the background.  **Important**: When async processing is enabled, the rules list in the API response will not be up-to-date immediately after update. You should refetch the alert route after a few minutes to get the updated rules.  If you experience slow operations when managing alert routes with many rules, contact Rootly customer support to enable asynchronous rule processing for your organization.
     * @param id  (required)
     * @param updateAlertRoute  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> update: handles mixed position types correctly </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> update: raises error when multiple fallback rules are present </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> cross-team access denied </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateAlertRouteAsync(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull UpdateAlertRoute updateAlertRoute, final ApiCallback<AlertRouteResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateAlertRouteValidateBeforeCall(id, updateAlertRoute, _callback);
        Type localVarReturnType = new TypeToken<AlertRouteResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
